// Specification describing the following line:
//
//   \  /
//   |s0|s1|s2|
//         /  \
//
//   s0, s1, s2 means 0th, 1st, and 2nd segments and one can place an items at s0 and
//   the line eject the item at s2
//
var lineSpec = {
  segments: [
    {
      id: 0,
      to: 1, // segment_id
      from: null, // segment_id
    },
    {
      id: 1,
      to: 2,
      from: 0,
    },
    {
      id: 2,
      to: null,
      from: 1,
    },
  ],
  placer: {
    to: 0, // segment_id
  },
  ejector: {
    from: 2, // segment_id
  },
};

// A utility function that converts a specification into a data structure that is easier
// to work with
var createLine = function (lineSpec) {
  var createSegments = function (segment) {
    if (segment === null) {
      return null;
    } else {
      var nextSegment =
        find(function (seg) {
          return seg.id === segment.to;
        }, lineSpec.segments) || null;
      return {
        id: segment.id,
        next: createSegments(nextSegment),
        item: null,
        duration: null,
      };
    }
  };
  var line = {
    // assume "lineSpec.segments[0]" is the first segment
    firstSegment: createSegments(lineSpec.segments[0]),
  };
  return line;
};

// A factory function that returns "run", a function that simulates processing the line
// for "maxNumSteps" "step"s and returns "duration" taken to process all "inputItems".
var createRun = function (lineSpec) {
  var line = createLine(lineSpec);

  // A utility function for taking a "step"
  var step = function (segment, newItem) {
    if (segment.next === null) {
      if (newItem !== null) {
        return [true, segment, newItem];
      } else {
        return [false, segment, null];
      }
    }

    if (newItem !== null) {
      // need to place "newItem" on "segment"
      if (segment.item !== null) {
        // "segment" has "segment.item"
        if (segment.duration === 0) {
          // "segment.item" is ready to be moved to "segment.next"
          // let's see if we can place "segment.item" on "segment.next"
          var stepResult = step(segment.next, segment.item);
          var itemMoved = stepResult[0];
          var nextSegment = stepResult[1];
          var outItem = stepResult[2];
          if (itemMoved) {
            // "segment.item" is placed on "nextSegment"
            // placing "newItem" on "segment"
            return [
              true,
              Object.assign({}, segment, {
                next: nextSegment,
                item: newItem,
                duration: sample(Poisson({ mu: 2 })),
              }),
              outItem,
            ];
          } else {
            // "segment.item" is not placed on "nextSegment"
            // making no change
            return [
              false,
              Object.assign({}, segment, { next: nextSegment }),
              outItem,
            ];
          }
        } else {
          // "segment.item" is not ready to be moved to "segment.next"; it needs to stay
          // in "segment" for remaining "segment.duration"
          var stepResult = step(segment.next, null);
          var itemMoved = stepResult[0];
          var nextSegment = stepResult[1];
          var outItem = stepResult[2];
          // reducing duration by 1
          return [
            false,
            Object.assign({}, segment, {
              next: nextSegment,
              duration: segment.duration - 1,
            }),
            outItem,
          ];
        }
      } else {
        // placing "newItem" on "segment"
        var stepResult = step(segment.next, null);
        var itemMoved = stepResult[0];
        var nextSegment = stepResult[1];
        var outItem = stepResult[2];
        return [
          true,
          Object.assign({}, segment, {
            next: nextSegment,
            item: newItem,
            duration: sample(Poisson({ mu: 2 })),
          }),
          outItem,
        ];
      }
    } else {
      // no need to place "newItem" on "segment"
      if (segment.item !== null) {
        // "segment" has "segment.item"
        if (segment.duration === 0) {
          // "segment.item" is ready to be moved to "segment.next"
          // let's see if we can place "segment.item" on "segment.next"
          var stepResult = step(segment.next, segment.item);
          var itemMoved = stepResult[0];
          var nextSegment = stepResult[1];
          var outItem = stepResult[2];
          if (itemMoved) {
            // "segment.item" is placed on "nextSegment"
            return [
              false,
              Object.assign({}, segment, {
                next: nextSegment,
                item: null,
                duration: null,
              }),
              outItem,
            ];
          } else {
            // "segment.item" is not placed on "nextSegment"
            // making no change
            return [
              false,
              Object.assign({}, segment, { next: nextSegment }),
              outItem,
            ];
          }
        } else {
          // "segment.item" is not ready to be moved to "segment.next"; it needs to stay
          // in "segment" for remaining "segment.duration"
          var stepResult = step(segment.next, null);
          var itemMoved = stepResult[0];
          var nextSegment = stepResult[1];
          var outItem = stepResult[2];
          // reducing duration by 1
          return [
            false,
            Object.assign({}, segment, {
              next: nextSegment,
              duration: segment.duration - 1,
            }),
            outItem,
          ];
        }
      } else {
        // making no change
        var stepResult = step(segment.next, null);
        var itemMoved = stepResult[0];
        var nextSegment = stepResult[1];
        var outItem = stepResult[2];
        return [
          false,
          Object.assign({}, segment, { next: nextSegment }),
          outItem,
        ];
      }
    }
  };

  var run = function (inputItems, maxNumSteps) {
    // webppl does not allow for/while, so using reduce instead
    var initState = {
      line: line,
      inputItems: inputItems,
      outputItems: [],
      finished: false,
      duration: 0,
    };
    var ticks = repeat(maxNumSteps, function () {
      return 1;
    });
    var finalState = reduce(
      function (tick, state) {
        var stepResult = step(
          state.line.firstSegment,
          state.inputItems.length > 0 ? state.inputItems[0] : null
        );
        var curInputItems = stepResult[0]
          ? mapN(function (idx) {
              // poor man's "state.inputItems.slice(0)"
              return state.inputItems[idx + 1];
            }, state.inputItems.length - 1)
          : state.inputItems;
        var curOutputItems =
          stepResult[2] !== null
            ? mapN(function (idx) {
                // poor man's "state.outputItems.concat(stepResult[2])"
                return idx < state.outputItems.length
                  ? state.outputItems[idx]
                  : stepResult[2];
              }, state.outputItems.length + 1)
            : state.outputItems;
        var newLine = Object.assign({}, state.line, {
          firstSegment: stepResult[1],
        });
        var finished = // poor man's deep equality
          curOutputItems.length === inputItems.length &&
          all(
            function (a) {
              return a;
            },
            map2(
              function (a, b) {
                return a === b;
              },
              curOutputItems,
              inputItems
            )
          );
        return Object.assign({}, state, {
          line: newLine,
          inputItems: curInputItems,
          outputItems: curOutputItems,
          duration: state.duration + (!finished ? tick : 0), // don't advance the clock once it's done
        });
      },
      initState,
      ticks
    );

    return finalState.duration;
  };
  return run;
};

// Sample possible "duration"s
var run = createRun(lineSpec);
var inputItems = ["a", "b"];
var maxNumSteps = 20;
var marginal = Infer(function () {
  return run(inputItems, maxNumSteps);
});
// print distribution over possible durations of running the line
marginal.getDist();
